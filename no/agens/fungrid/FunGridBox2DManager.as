package no.agens.fungrid {	import flash.geom.Point;	import Box2D.Common.Math.b2Vec2;	import Box2D.Dynamics.b2World;	import Box2D.Dynamics.b2Body;	import Box2D.Dynamics.b2BodyDef;	import flash.display.Sprite;	import flash.display.MovieClip;	import Box2D.Collision.Shapes.b2CircleShape;	import Box2D.Dynamics.b2FixtureDef;	import Box2D.Collision.Shapes.b2PolygonShape;	//	// Using Box2D V2.1A	//	public class FunGridBox2DManager {		public static var RATIO:Number;		public static var WORLD:b2World;		public function FunGridBox2DManager(ratio:Number=30, gravity:Point = null,doSleep:Boolean = true) {			RATIO=ratio;			if (gravity==null) {				gravity = new Point();			}			WORLD=new b2World(new b2Vec2(gravity.x,gravity.y),doSleep);		}		// Usually dt = 1/FPS		public function update(dt:Number, iterations:int=10):void {			WORLD.Step(dt,iterations,iterations);			WORLD.ClearForces();		}		// bodyType b2Body.b2_dynamicBody, b2Body.b2_staticBody, b2Body.b2_kineticBody		public function addCircle(bodyType:uint, position:Point,radius:Number, friction:Number=0.5, restitution:Number=0.3, density:Number=0, angle_RADIANS:Number = 0, initVelocity:Point = null, initOmega:Number = 0, isSensor:Boolean = false, fixedRotation:Boolean = false):b2Body {			var shapeDef:b2CircleShape = new b2CircleShape(radius/RATIO);			var fixtureDef:b2FixtureDef = new b2FixtureDef();			fixtureDef.shape=shapeDef;			fixtureDef.friction=friction;			fixtureDef.restitution=restitution;			fixtureDef.density=density;			fixtureDef.isSensor=isSensor;			var body:b2Body=createBody(bodyType,position,angle_RADIANS,initVelocity,initOmega,fixedRotation);			body.CreateFixture(fixtureDef);			return body;		}		public function createBody(bodyType:uint, position:Point, angle_RADIANS:Number = 0, initVelocity:Point = null, initOmega:Number = 0, fixedRotation:Boolean = false):b2Body {			var bodyDef:b2BodyDef = new b2BodyDef();			bodyDef.position.Set(position.x/RATIO, position.y/RATIO);			bodyDef.angle=angle_RADIANS;			bodyDef.fixedRotation=fixedRotation;			bodyDef.type=bodyType;			var body:b2Body=WORLD.CreateBody(bodyDef);			if (initVelocity==null) {				initVelocity=new Point(0,0);			}			var velocityVector:b2Vec2=new b2Vec2(initVelocity.x/RATIO,initVelocity.y/RATIO);			body.SetLinearVelocity(velocityVector);			body.SetAngularVelocity(initOmega);			return body;		}		public function addPolygons(bodyType:int, position:Point, polygonsCoordVectors:Vector.<Vector.<Point>>,body:b2Body = null,friction:Number=0.5, restitution:Number=0.3, density:Number=0, angle_RADIANS:Number = 0, initVelocity:Point = null, initOmega:Number = 0, isSensor:Boolean = false):b2Body {			var allShapeDefs:Vector.<b2PolygonShape> = new Vector.<b2PolygonShape>();			for (var i:int = 0; i<polygonsCoordVectors.length; i++) {				var shapeDef:b2PolygonShape = new b2PolygonShape();				var array:Array = new Array();				for (var j:int = 0; j<polygonsCoordVectors[i].length; j++) {					array.push(new b2Vec2(polygonsCoordVectors[i][j].x/RATIO, polygonsCoordVectors[i][j].y/RATIO));				}				shapeDef.SetAsArray(array, array.length);				allShapeDefs.push(shapeDef);			}			var fixtureDef:b2FixtureDef = new b2FixtureDef();			fixtureDef.friction=friction;			fixtureDef.restitution=restitution;			fixtureDef.density=density;			fixtureDef.isSensor=isSensor;			if (body==null) {				body=createBody(bodyType,position,angle_RADIANS,initVelocity,initOmega);			}			for (var k:int = 0; k<allShapeDefs.length; k++) {				fixtureDef.shape=allShapeDefs[k];				body.CreateFixture(fixtureDef);			}			return body;		}		public function spriteFromPolygons(polygonsCoordVectors:Vector.<Vector.<Point>>,thickness:Number = 2, color:uint=0x00BB00, fillColor:uint=0x00FF00, drawingSprite:Sprite = null):Sprite {			var sprite:Sprite;			if (drawingSprite==null) {				sprite = new Sprite();			} else {				sprite=drawingSprite;			}			sprite.graphics.lineStyle(thickness, color);			for (var i:int = 0; i<polygonsCoordVectors.length; i++) {				var firstPoint:Point=polygonsCoordVectors[i][0];				sprite.graphics.moveTo(firstPoint.x, firstPoint.y);				sprite.graphics.beginFill(fillColor);				for (var j:int = 0; j<polygonsCoordVectors[i].length; j++) {					sprite.graphics.lineTo(polygonsCoordVectors[i][j].x, polygonsCoordVectors[i][j].y);				}				sprite.graphics.lineTo(firstPoint.x, firstPoint.y);				sprite.graphics.endFill();			}			return sprite;		}		/** Not sure if this is really working... */		public function worldIsSleeping():Boolean {			var isSleeping:Boolean=true;			for (var bb:b2Body = WORLD.GetBodyList(); bb; bb = bb.GetNext()) {				if (bb.IsAwake()&&bb.IsSleepingAllowed()) {					isSleeping=false;				}			}			return isSleeping;		}		public function movieClipFromPolygons(polygonsCoordVectors:Vector.<Vector.<Point>>,thickness:Number = 2, color:uint=0x00BB00, fillColor:uint=0x00FF00, drawingSprite:MovieClip = null):MovieClip {			var sprite:MovieClip;			if (drawingSprite==null) {				sprite = new MovieClip();			} else {				sprite=drawingSprite;			}			sprite.graphics.lineStyle(thickness, color);			for (var i:int = 0; i<polygonsCoordVectors.length; i++) {				var firstPoint:Point=polygonsCoordVectors[i][0];				sprite.graphics.moveTo(firstPoint.x, firstPoint.y);				sprite.graphics.beginFill(fillColor);				for (var j:int = 0; j<polygonsCoordVectors[i].length; j++) {					sprite.graphics.lineTo(polygonsCoordVectors[i][j].x, polygonsCoordVectors[i][j].y);				}				sprite.graphics.lineTo(firstPoint.x, firstPoint.y);				sprite.graphics.endFill();			}			return sprite;		}		public function addBox(bodyType:uint,position:Point,width:Number,height:Number,friction:Number=0.5, restitution:Number=0.3, density:Number=0, angle_RADIANS:Number = 0, initVelocity:Point = null, initOmega:Number = 0, isSensor:Boolean = false,fixedRotation:Boolean = false):b2Body {			var shapeDef:b2PolygonShape = new b2PolygonShape();			shapeDef.SetAsBox(0.5*width/RATIO, 0.5*height/RATIO);			var fixtureDef:b2FixtureDef = new b2FixtureDef();			fixtureDef.shape=shapeDef;			fixtureDef.friction=friction;			fixtureDef.restitution=restitution;			fixtureDef.density=density;			fixtureDef.isSensor=isSensor;			var body:b2Body=createBody(bodyType,position,angle_RADIANS,initVelocity,initOmega,fixedRotation);			body.CreateFixture(fixtureDef);			return body;		}	}}