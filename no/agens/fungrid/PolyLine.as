package no.agens.fungrid{	import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Point;	import flash.geom.Rectangle;	/*	Copyright (c) 2011, Agens AS <post@agens.no> http://agens.no		Permission to use, copy, modify, and/or distribute this software for any	purpose with or without fee is hereby granted, provided that the above	copyright notice and this permission notice appear in all copies.		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.	*/	/**	 * <h1>PolyLine</h1>	 * <p>Line of 2 or more points (1 or more line segments). Usually used to define platforms (open PolyLine) or zones (closed PolyLine) on the FunGrid</p>	 *  	 * Usgae: Create and use it while creating PolyLineGameObjects or PolyLineZoneGameObjects. Positions are relative to the game object.	 * The first point should usually be the left-most point when creating platforms.	 * 	 * @author Peter Måseide, Agens AS	 * @date 18. jan. 2011	 */		public class PolyLine {				public var points:Vector.<Point > ;		/** Length of the different line segments */		public var lengths:Vector.<Number > ;		/** Derivatives of the different line segments */		public var derivatives:Vector.<Number > ;		/** Total length of all line segments */		public var totalLength:Number;		/** If the PolyLine is closed or not. Closed = first point is the same position as the last point */		private var closed:Boolean;		/** Bounding rectangle */		public var boundRect:Rectangle;		/** It's possible to draw the PolyLine on a Shape */		private var shape:Shape;		/** */		public var lastCollisionPointParameter:Number;		/**		 * Constructor 		 * @param p1 First point - The first point should usually be the left-most point when creating platforms.		 * @param p2 Second point		 * @param morePoints		 * 		 */				public function PolyLine(p1:Point, p2:Point, ...morePoints):void {			points = new Vector.<Point>();			points.push(p1);			points.push(p2);			if (morePoints) {				var l:int = morePoints.length;				for (var i:int = 0; i<l; i++) {					if (morePoints[i] is Point) {						points.push(morePoints[i]);					}				}			}			init();		}		/**		 * If a point is inside a closed PolyLine 		 * @param p Point		 * @return True if point is insinde		 * 		 */				public function containsPoint(p:Point):Boolean {			if (! boundRect.containsPoint(p) || ! closed) {				return false;			}			var inside:Boolean = false;			var xold = points[points.length - 1].x;			var yold = points[points.length - 1].y;			var x1:Number;			var y1:Number;			var x2:Number;			var y2:Number;			var xnew:Number;			var ynew:Number;			for (var i:int=0; i < points.length; i++) {				xnew = points[i].x;				ynew = points[i].y;				if (xnew > xold) {					x1 = xold;					x2 = xnew;					y1 = yold;					y2 = ynew;				} else {					x1 = xnew;					x2 = xold;					y1 = ynew;					y2 = yold;				}				if ((xnew < p.x) == (p.x <= xold) && ((p.y-y1)*(x2-x1) < (y2-y1)*(p.x-x1))) {					inside = ! inside;				}				xold = xnew;				yold = ynew;			}			return inside;		}		/**		 * If a rectangle intersects boundRect 		 * @param r Rectangle		 * @return True if rectangle intersects boundRect		 * 		 */				public function intersectsBoundRect(r:Rectangle):Boolean {			if (boundRect.intersects(r)) {				return true;			}			return false;		}		/**		 * Returns a intersection point between two line segments if the point is inside both line segments		 * @param line1a Line segment 1 start point		 * @param line1b Line segment 1 end point		 * @param line2a Line segment 2 start point		 * @param line2b Line segment 2 end point		 * @return 		 * 		 */				public function intersectionPoint(line1a:Point,line1b:Point,line2a:Point,line2b:Point):Point {			// Formula based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/			var nemnar:Number = (line2b.y-line2a.y)*(line1b.x-line1a.x)-(line2b.x-line2a.x)*(line1b.y-line1a.y);			if (nemnar != 0) {				var ua_teljar:Number = (line2b.x-line2a.x)*(line1a.y-line2a.y)-(line2b.y-line2a.y)*(line1a.x-line2a.x);				var ub_teljar:Number = (line1b.x-line1a.x)*(line1a.y-line2a.y)-(line1b.y-line1a.y)*(line1a.x-line2a.x);				var ua:Number = ua_teljar / nemnar;				var ub:Number = ub_teljar / nemnar;				// Check if we are inside both line segments:				if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {					return new Point(line1a.x+ua*(line1b.x-line1a.x), line1a.y+ua*(line1b.y-line1a.y));				}			}			return null;		}				/**		 * Returns closest collision point or null 		 * @param from Point from where the possible colliding object is comming		 * @param to Point to where the possible colliding object is heading		 * @return Closest collision point or null		 * 		 */				public function collisionPoint(from:Point, to:Point):Point {			var closestPoint:Point;			var parameter:Number = 0;			var l:int = points.length;			var ip:Point;			for (var i:int = 0; i<l-1; i++) {				ip = intersectionPoint(from,to,points[i],points[i + 1]);				if (ip) {					if (closestPoint) {						if (Math.sqrt((ip.x-from.x)*(ip.x-from.x)+(ip.y-from.y)*(ip.y-from.y)) < Math.sqrt((closestPoint.x-from.x)*(closestPoint.x-from.x)+(closestPoint.y-from.y)*(closestPoint.y-from.y))) {							closestPoint = ip;							lastCollisionPointParameter = parameter + Math.sqrt((ip.x-points[i].x)*(ip.x-points[i].x)+(ip.y-points[i].y)*(ip.y-points[i].y));						}					} else {						closestPoint = ip;						lastCollisionPointParameter = parameter + Math.sqrt((ip.x-points[i].x)*(ip.x-points[i].x)+(ip.y-points[i].y)*(ip.y-points[i].y));					}				}				parameter +=  lengths[i];			}			return closestPoint;		}		/**		 * Returns the derivative for the point on the PolyLine defined by a parameter value		 * @param parameter Defines a point on the PolyLine by the distance from the first point on the PolyLine		 * @return Derivative in the point given by the parameter		 * 		 */				public function derivativeFromParameter(parameter:Number):Number {			var len:int = lengths.length;			for (var i:int = 0; i<len; i++) {				if (parameter > lengths[i]) {					parameter -=  lengths[i];				} else {					return derivatives[i];				}			}			if (parameter<0) {				return derivatives[0];			}			return derivatives[derivatives.length-1];		}		/**		 * Return a point on the PolyLine defined by a parameter value 		 * @param parameter Defines a point on the PolyLine by the distance from the first point on the PolyLine		 * @param returnPointsOutsidePolyLien If we should return points outside of the PolyLine. (For open PolyLines.) Will then return a point like if the line will go on forever in each end.		 * @return Point given by the parameter		 * 		 */				public function pointFromParameter(parameter:Number, returnPointsOutsidePolyLine:Boolean = false):Point {			if (returnPointsOutsidePolyLine) {				if (parameter < 0) {					return Point.polar(parameter,Math.atan(derivatives[0])).add(points[0]);				} else if (parameter>totalLength) {					parameter -=  totalLength;					return Point.polar(parameter,Math.atan(derivatives[derivatives.length-1])).add(points[points.length-1]);				}			}			if (closed) {				// Move parameter to a point withing the totalLength if the polyline is closed.				while (parameter<0) {					parameter +=  totalLength;				}				while (parameter>totalLength) {					parameter -=  totalLength;				}			} else if (parameter<0 || parameter>totalLength) {				return null;			}			var l:Number = 0;			var len:int = lengths.length;			for (var i:int = 0; i<len; i++) {				if (parameter > lengths[i]) {					parameter -=  lengths[i];				} else {					return new Point(points[i].x+parameter*(points[i+1].x-points[i].x)/lengths[i], points[i].y+parameter*(points[i+1].y-points[i].y)/lengths[i]);				}			}			return null;		}		/**		 * If the PolyLine is closed, meaning that the first point is the exact same location as the last point.		 * @return True if closed		 * 		 */				public function isClosed():Boolean {			return closed;		}		/**		 * Make the PolyLine closed. Adds a point with the same coordinates as the first point, if it's not already closed. 		 * 		 */				public function close():void {			if (! closed) {				points.push(new Point(points[0].x, points[0].y));				closed = true;			}		}		/**		 * Init and precalculations on creation of the PolyLine		 * 		 */				private function init():void {			lengths = new Vector.<Number >   ;			derivatives = new Vector.<Number >   ;			totalLength = 0;			var minX:Number;			var minY:Number;			var maxX:Number;			var maxY:Number;			var len:int = points.length;			for (var i:int = 0; i<len; i++) {				if (i < points.length - 1) {					var l:Number = Math.sqrt((points[i+1].x-points[i].x)*(points[i+1].x-points[i].x)+(points[i+1].y-points[i].y)*(points[i+1].y-points[i].y));					lengths.push(l);					derivatives.push((points[i+1].y-points[i].y)/(points[i+1].x-points[i].x));					totalLength +=  l;				}				if (i == 0) {					minX = maxX = points[i].x;					minY = maxY = points[i].y;				} else {					if (points[i].x < minX) {						minX = points[i].x;					} else if (points[i].x>maxX) {						maxX = points[i].x;					}					if (points[i].y < minY) {						minY = points[i].y;					} else if (points[i].y>maxY) {						maxY = points[i].y;					}				}			}			boundRect = new Rectangle(minX,minY,maxX - minX,maxY - minY);			// Set height and width to minimum 1 to be able to union the boundRect with other boundRect (like in the PolyLineGameObject constructor)			if (boundRect.height ==0) {				boundRect.height = 1;			}			if (boundRect.width ==0) {				boundRect.width = 1;			}			if (points[0].x == points[points.length - 1].x && points[0].y == points[points.length - 1].y) {				closed = true;			}		}		/**		 * Draws the PolyLine onto a Sprite. Mainly for debugging purposes.		 * @param sprite Sprite to draw the shape on		 * @param thickness Thickness of the line		 * @param color Color of the line		 * 		 */				public function draw(sprite:Sprite, thickness:int = 1, color:uint = 0xFF0000):void {			if (shape==null) {				shape=new Shape();			}			shape.graphics.clear();			shape.graphics.lineStyle(thickness,color);			shape.graphics.moveTo(points[0].x,points[0].y);			for (var i:uint=1; i<points.length; i++) {				shape.graphics.lineTo(points[i].x,points[i].y);			}			sprite.addChild(shape);		}		/**		 * Removes the drawing of the PolyLine from the sprite 		 * @param sprite Sprite we have drawn the shape on		 * @return 		 * 		 */				public function undraw(sprite:Sprite) {			if (shape) {				sprite.removeChild(shape);				shape = null;			}		}	}}