package no.agens.fungrid {	import flash.display.BitmapData;	import flash.geom.Rectangle;	import flash.geom.Point;		public class BlitCoreGameObject extends BlitHardCoreGameObject {		/** True if this GO is supposed to move on the GameGrid with speed/acceleration */		public var moveable:Boolean;		/** x and y speed of the GO on the GameGrid. Measured in pixels pr update (frame). */		public var speed:Point;		/** x and y acceleration of the GO on the GameGrid. Measures change in speed in pixels pr update (frame). */		public var acceleration:Point;				/** Interval defining min and max for speed.x */		public var speedIntervalX:Interval;		/** Interval defining min and max for speed.y */		public var speedIntervalY:Interval;		/** speed.x is multiplied with this Number on each update. */		public var speedChangeFactorX:Number = 1;		/** speed.y is multiplied with this Number on each update. */		public var speedChangeFactorY:Number = 1;		public function BlitCoreGameObject(id:String,spriteSheet:BitmapData, spriteRects:Vector.<Rectangle>, initPos:Point, scrollFactor:Point=null, animateSprites:Boolean = false, moveable:Boolean = true, initSpeed:Point=null, initAcceleration:Point=null) {			super(id,spriteSheet,spriteRects,initPos,scrollFactor,animateSprites);			this.moveable = moveable;			if (initSpeed==null) {				speed = new Point(0,0);			} else {				if (!moveable) {					trace("Warning - CoreGameObject id='"+id+"' : moveable is false, but it has initSpeed");				}				speed = initSpeed;			}			if (initAcceleration==null) {				acceleration = new Point(0,0);			} else {				if (!moveable) {					trace("Warning - CoreGameObject id='"+id+"' : moveable is false, but has initAcc");				}				acceleration = initAcceleration;			}		}		/** Updates the position on the grid and the DisplayObjects position in the viewport, and then render... */		override public function update():Boolean {			if (destroyMe) {				return false;			}			customEarlyUpdate();			if (moveable) {				updateSpeed();				updateGridPosition();			}			customLateUpdate();			updateRenderPositon();			render();						return true;		}		/** Updates the speed by using acceleration. */		protected function updateSpeed():void {			speed.x +=  acceleration.x;			speed.x *= speedChangeFactorX;			if (speedIntervalX) {				speed.x = speedIntervalX.forceIntoInterval(speed.x);			}			speed.y +=  acceleration.y;			speed.y *= speedChangeFactorY;			if (speedIntervalY) {				speed.y = speedIntervalY.forceIntoInterval(speed.y);			}		}		/** Updates the positon on the grid by using speed. */		protected function updateGridPosition():void {			pos.x +=  speed.x;			pos.y +=  speed.y;		}		/** Custom update after updateGridPosition */		protected function customLateUpdate():void {		}			}	}