package no.agens.fungrid {	import flash.display.SimpleButton;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.display.Sprite;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.geom.Point;	public class FunGridBitmapTools {		public static function bitmapifySimpleButton(vectorButton:SimpleButton, width:uint=0, height:uint=0, transparent:Boolean = false, overAsUp:Boolean = false, downAsOver:Boolean = false):SimpleButton {			var sb:SimpleButton = new SimpleButton();			sb.upState = spriteToBitmapSprite(Sprite(vectorButton.upState), width, height, transparent);			if (overAsUp) {				sb.overState = sb.upState;			} else {				sb.overState = spriteToBitmapSprite(Sprite(vectorButton.overState), width, height, transparent);			}			if (downAsOver) {				sb.downState = sb.overState;			} else {				sb.downState = spriteToBitmapSprite(Sprite(vectorButton.downState), width, height, transparent);			}			sb.hitTestState = vectorButton.hitTestState;			return sb;		}		public static function spriteToBitmapData(s:Sprite, width:uint=0, height:uint=0, transparent:Boolean = false):BitmapData{			var newBmd:BitmapData;			if (width==0 || height==0) {				newBmd = new BitmapData(s.width, s.height,transparent,0);			} else {				newBmd = new BitmapData(width, height,transparent,0);			}			newBmd.draw(s);			return newBmd;		}		public static function spriteToBitmap(s:Sprite, width:uint=0, height:uint=0, transparent:Boolean=false):Bitmap {			return new Bitmap(spriteToBitmapData(s, width, height,transparent));		}		public static function spriteToBitmapSprite(s:Sprite, width:uint=0, height:uint=0,transparent:Boolean = false):Sprite {			var newSprite:Sprite = new Sprite();			newSprite.addChild(spriteToBitmap(s, width, height, transparent));			newSprite.cacheAsBitmap = true;			return newSprite;		}		public static function cropBitmapData(bmd:BitmapData, width:uint=0, height:uint=0, x:uint=0, y:uint=0):BitmapData {			var w:uint = width;			var h:uint = height;			if (w==0) {				w = bmd.width;			}			if (h==0) {				h = bmd.height;			}			var newBmd:BitmapData = new BitmapData(w, h);			newBmd.copyPixels(bmd,new Rectangle(x,y,w,h),new Point(0,0));			return newBmd;					}		public static function flipBitmapData(bmd:BitmapData, vertical:Boolean = false):BitmapData {			// Transformation matrix			var mtx:Matrix = new Matrix();			if (vertical) {				// Vertical flip / mirror				mtx.scale(1,-1);				mtx.translate(0,bmd.height);			} else {				// Horizontal flip / mirror				mtx.scale(-1,1);				mtx.translate(bmd.width,0);			}			var newBmd:BitmapData = new BitmapData(bmd.width, bmd.height, true,0);			newBmd.draw(bmd, mtx);			return newBmd;		}		public static function rotateBitmapDataCW(bmd:BitmapData, rotationsCW:uint = 1):BitmapData {			var w:uint = bmd.width;			var h:uint = bmd.height;			if (rotationsCW % 2==1) {				w = bmd.height;				h = bmd.width;			}			// Transformation matrix			var mtx:Matrix = new Matrix();			// Rotate bitmapdata			mtx.rotate(0.5*Math.PI*(rotationsCW % 4));			// Move bitmapdata in place after rotation			if (rotationsCW % 4==1) {				mtx.translate(w,0);			} else if (rotationsCW % 4==2) {				mtx.translate(w,h);			} else if (rotationsCW % 4==3) {				mtx.translate(0,h);			}			var newBmd:BitmapData = new BitmapData(w,h);			newBmd.draw(bmd, mtx);			return newBmd;		}	}}