package no.agens.fungrid {	import flash.display.Sprite;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.geom.Matrix;	/*	Copyright (c) 2011, Agens AS <post@agens.no> http://agens.no		Permission to use, copy, modify, and/or distribute this software for any	purpose with or without fee is hereby granted, provided that the above	copyright notice and this permission notice appear in all copies.		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.	*/	/**	 * <h1>GameObject</h1>	 * <p>GameObject on the FunGrid</p>	 * 	 * Usgae: Create GameObjects and add them to the FunGrid!	 * 	 * @author Peter Måseide, Agens AS	 * @date 21. mar. 2011	 */	public class GameObject {		/** A string you can use to identify the GO */		public var id:String;		/** A string you can use to classify the GO */		public var type:String;		/** Reference to the FunGrid the GO is added on */		public var fg:FunGrid;		/** The visual part of the GameObject. Is added to baseSprite on FunGrid when GO is added to the FunGrid */		public var sprite:Sprite;		/** Positon for the GO on the FunGrid*/		public var pos:Point;		/** True if this GO is supposed to move on the GameGrid with speed/acceleration */		public var moveable:Boolean;		/** x and y speed of the GO on the GameGrid. Measured in pixels pr update (frame). */		public var speed:Point;		/** x and y acceleration of the GO on the GameGrid. Measures change in speed in pixels pr update (frame). */		public var acc:Point;		/** How the GO follows GameGrid.baseSprite when scrolling. (Default: x:1 y:1 - Use values below 1 to scroll backgrounds slower, and values above 1 to scroll things in the foreground faster.) */		public var scrollFactor:Point;		/** BoundingRectangle for the visible part of the Sprite*/		public var boundRect:Rectangle;		/** Reference to the baseSprite on the FunGrid */		public var baseSprite:Sprite;		/** True if we want to render the Sprite even if it's outside the GameGrid viewport */		public var neverHide:Boolean = false;		/** True if the GO is supposed to be removed from the GameGrid */		public var destroyMe:Boolean = false;		/** True if we are doing depth sorting on update */		public var doDepthSorting:Boolean = false;		/** Value for depth sorting GameObjects */		public var depthIndex:int = 0;		/** Offset from pos when depthsorting */		public var depthOffset:Point = new Point(0,0);		/** Repeat settings */		public var repeatSettings:GameObjectRepeatSettings;		/** Rotation speed for sprite. Measured in degrees pr update (frame) */		public var spriteRotationSpeed:Number = 0;						/**		 * Constructor 		 * @param id A string you can use to identify the GO		 * @param sprite The visual part of the GameObject. Is added to baseSprite on FunGrid when GO is added to the FunGrid		 * @param pos Positon for the GO on the FunGrid		 * @param scrollFactor How the GO follows GameGrid.baseSprite when scrolling. (Default: x:1 y:1 - Use values below 1 to scroll backgrounds slower, and values above 1 to scroll things in the foreground faster.)		 * @param moveable True if this GO is supposed to move on the GameGrid with speed/acceleration		 * @param repeatSettings Repeat settings		 * @param speed x and y speed of the GO on the GameGrid. Measured in pixels pr update (frame)		 * @param acc x and y acceleration of the GO on the GameGrid. Measures change in speed in pixels pr update (frame).		 * 		 */				public function GameObject(id:String,sprite:Sprite,pos:Point,scrollFactor:Point=null, moveable:Boolean = true, repeatSettings:GameObjectRepeatSettings = null, speed:Point=null, acc:Point=null) {			this.id = id;			this.sprite = sprite;			if (sprite) {				sprite.x = -sprite.width*2;				sprite.y = -sprite.height*2;			}			boundRect = sprite.getBounds(sprite);			if (scrollFactor == null) {				this.scrollFactor = new Point(1,1);			} else {				this.scrollFactor = scrollFactor;			}			this.pos = new Point(pos.x/this.scrollFactor.x,pos.y/this.scrollFactor.y);			this.moveable = moveable;			this.repeatSettings = repeatSettings;			if (speed==null) {				this.speed = new Point(0,0);			} else {				this.speed = speed;			}			if (acc==null) {				this.acc = new Point(0,0);			} else {				this.acc = acc;			}		}				/** Updates the position on the grid and the Sprites position in the viewport, and then render... */		public function update():Boolean {			if (destroyMe) {				return false;			}			customUpdateBeforeGridPosition();			if (moveable) {				updateGridPosition();			}			customUpdateAfterGridPosition();			updateViewportPositon();			if (repeatSettings) {				updateRepeat();			}			if (doDepthSorting) {				calculateDepthIndex();			}			render();						return true;		}		/** Updates the depthIndex, based on the screen position and depthOffset */		protected function calculateDepthIndex():void {			depthIndex = (sprite.y+depthOffset.y)*fg.viewport.width+sprite.x+depthOffset.x;		}		/** Updates the positon on the grid by using speed and acceleration. */		protected function updateGridPosition():void {			speed.x +=  acc.x;			speed.y +=  acc.y;			pos.x +=  speed.x;			pos.y +=  speed.y;			if (sprite) {				sprite.rotation += spriteRotationSpeed;			}		}		/** Your own custom update before the position is updated */		protected function customUpdateBeforeGridPosition():void {		}		/** Your own custom update after the position is updated */		protected function customUpdateAfterGridPosition():void {		}		/** Shows the sprite if the sprite is inside the viewport */		protected function render():void {			if (sprite) {				if (neverHide) {					customRender();					sprite.visible = true;				} else if (inViewport()) {					customRender();					sprite.visible = true;				} else {					sprite.visible = false;				}			}		}		/** Your own custom render */		protected function customRender():void {		}		/**		 * Used by the FunGrid when adding the GO.		 * @param fg FunGrid		 * @param baseSprite FunGrid baseSprite		 * 		 */				public function setFunGrid(fg:FunGrid,baseSprite:Sprite):void {			this.fg = fg;			this.baseSprite = baseSprite;		}		/** Updates the position of the sprite in the viewport */		public function updateViewportPositon():void {			if (sprite) {				if (scrollFactor.x != 0) {					sprite.x=scrollFactor.x*(pos.x-fg.viewport.x);				} else {					sprite.x = pos.x;				}				if (scrollFactor.y != 0) {					sprite.y=scrollFactor.y*(pos.y-fg.viewport.y);				} else {					sprite.y = pos.y;				}			}		}		/** Updates possible repetition of the game object */		public function updateRepeat():void {			// Possible repeat of the instance on the funGrid when it's outside of the screen				if (repeatSettings.repeatEveryX) {					if (sprite.x+boundRect.width+boundRect.x<0) {						pos.x += repeatSettings.repeatEveryX/scrollFactor.x;						if (repeatSettings.noRepeatAfterX) {							if (pos.x>repeatSettings.noRepeatAfterX) {								pos.x -= repeatSettings.repeatEveryX/scrollFactor.x;							}						}						updateViewportPositon();					} else if (sprite.x+boundRect.x>repeatSettings.repeatEveryX-boundRect.width) {						pos.x -= repeatSettings.repeatEveryX/scrollFactor.x;						if (repeatSettings.noRepeatBeforeX) {							if (pos.x<repeatSettings.noRepeatBeforeX) {								pos.x += repeatSettings.repeatEveryX/scrollFactor.x;							}						}						updateViewportPositon();					}				}				if (repeatSettings.repeatEveryY) {					if (sprite.y+boundRect.height+boundRect.y<0) {						pos.y += repeatSettings.repeatEveryY/scrollFactor.y;						if (repeatSettings.noRepeatAfterY) {							if (pos.y>repeatSettings.noRepeatAfterY) {								pos.y -= repeatSettings.repeatEveryY/scrollFactor.y;							}						}						updateViewportPositon();					} else if (sprite.y+boundRect.y>repeatSettings.repeatEveryY-boundRect.height) {						pos.y -= repeatSettings.repeatEveryY/scrollFactor.y;						if (repeatSettings.noRepeatBeforeY) {							if (pos.y<repeatSettings.noRepeatBeforeY) {								pos.y += repeatSettings.repeatEveryY/scrollFactor.y;							}						}						updateViewportPositon();					}				}		}		/** If sprite is inside the viewport */		public function inViewport():Boolean {			return boundRect.x+sprite.x<=fg.viewport.width/fg.parentSprite.scaleX&&boundRect.right+sprite.x>=0&&boundRect.top+sprite.y<=fg.viewport.height/fg.parentSprite.scaleY&&boundRect.bottom+sprite.y>=0;		}		/** Make it possible for FunGrid to remove this GameObject */		public function pleaseDestroy():void {			destroyMe = true;			sprite.visible = false;		}		/** Used by the FunGrid when destroying the GO. */		public function destroy():void {			customDestroy();			if (baseSprite) {				baseSprite.removeChild(sprite);			}			sprite=null;		}		/** Custom destroy actions */		protected function customDestroy():void {		}	}}