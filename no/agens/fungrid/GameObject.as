package no.agens.fungrid {	import flash.display.DisplayObject;	import flash.geom.Point;	/*	Copyright (c) 2011, Agens AS <post@agens.no> http://agens.no		Permission to use, copy, modify, and/or distribute this software for any	purpose with or without fee is hereby granted, provided that the above	copyright notice and this permission notice appear in all copies.		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.	*/	/**	 * <h1>GameObject</h1>	 * <p>GameObject on the FunGrid</p>	 * 	 * Usgae: Create GameObjects and add them to the FunGrid!	 * 	 * @author Peter Måseide, Agens AS	 * @date 4. may 2011	 */	public class GameObject extends CoreGameObject {		public var type:String;		/** True if we are doing depth sorting on update */		public var doDepthSorting:Boolean = false;		/** Value for depth sorting GameObjects */		public var depthIndex:int = 0;		/** Offset from pos when depthsorting */		public var depthOffset:Point = new Point(0,0);		/** Repeat settings */		public var repeatSettings:RepeatSettings;		/** Rotation speed for displayObject. Measured in degrees pr update (frame) */		public var rotationSpeed:Number = 0;		/** Rotation acceleration ("change of speed") for displayObject. Measured in degrees pr update (frame) */		public var rotationAcceleration:Number = 0;						/**		 * Constructor 		 * @param id A string you can use to identify the GO		 * @param displayObject The visual part of the GameObject. Is added to baseSprite on FunGrid when GO is added to the FunGrid		 * @param initPos Positon for the GO on the FunGrid		 * @param scrollFactor How the GO follows GameGrid.baseSprite when scrolling. (Default: x:1 y:1 - Use values below 1 to scroll backgrounds slower, and values above 1 to scroll things in the foreground faster.)		 * @param moveable True if this GO is supposed to move on the GameGrid with speed/acceleration		 * @param repeatSettings Repeat settings		 * @param initSpeed x and y speed of the GO on the GameGrid. Measured in pixels pr update (frame)		 * @param initAcc x and y acceleration ("change of speed") of the GO on the GameGrid. Measures change in speed in pixels pr update (frame).		 * 		 */				public function GameObject(id:String,displayObject:DisplayObject,initPos:Point,scrollFactor:Point=null, moveable:Boolean = true, repeatSettings:RepeatSettings = null, initSpeed:Point=null, initAcceleration:Point=null) {			super(id, displayObject, initPos, scrollFactor, moveable, initSpeed, initAcceleration);			this.repeatSettings = repeatSettings;		}				/** Updates the position on the grid and the DisplayObjects position in the viewport, and then render... */		override public function update():Boolean {			if (destroyMe) {				return false;			}			customEarlyUpdate();			if (moveable) {				updateSpeed();				updateGridPosition();			}			customLateUpdate();			updateRenderPositon();			if (repeatSettings) {				updateRepeat();			}			if (doDepthSorting) {				calculateDepthIndex();			}			render();						return true;		}		/** Updates the depthIndex, based on the screen position and depthOffset */		protected function calculateDepthIndex():void {			depthIndex = (displayObject.y+depthOffset.y)*fg.viewport.width+displayObject.x+depthOffset.x;		}		/** Updates the positon on the grid by using speed and acceleration. */		override protected function updateGridPosition():void {			pos.x +=  speed.x;			pos.y +=  speed.y;			if (displayObject) {				rotationSpeed += rotationAcceleration;				displayObject.rotation += rotationSpeed;			}		}		/** Updates possible repetition of the game object */		public function updateRepeat():void {			// Possible repeat of the instance on the funGrid when it's outside of the screen				if (repeatSettings.repeatEveryX) {					if (displayObject.x+boundRect.width+boundRect.x<0) {						pos.x += repeatSettings.repeatEveryX/scrollFactor.x;						if (repeatSettings.noRepeatAfterX) {							if (pos.x>repeatSettings.noRepeatAfterX) {								pos.x -= repeatSettings.repeatEveryX/scrollFactor.x;							}						}						updateRenderPositon();					} else if (displayObject.x+boundRect.x>repeatSettings.repeatEveryX-boundRect.width) {						pos.x -= repeatSettings.repeatEveryX/scrollFactor.x;						if (repeatSettings.noRepeatBeforeX) {							if (pos.x<repeatSettings.noRepeatBeforeX) {								pos.x += repeatSettings.repeatEveryX/scrollFactor.x;							}						}						updateRenderPositon();					}				}				if (repeatSettings.repeatEveryY) {					if (displayObject.y+boundRect.height+boundRect.y<0) {						pos.y += repeatSettings.repeatEveryY/scrollFactor.y;						if (repeatSettings.noRepeatAfterY) {							if (pos.y>repeatSettings.noRepeatAfterY) {								pos.y -= repeatSettings.repeatEveryY/scrollFactor.y;							}						}						updateRenderPositon();					} else if (displayObject.y+boundRect.y>repeatSettings.repeatEveryY-boundRect.height) {						pos.y -= repeatSettings.repeatEveryY/scrollFactor.y;						if (repeatSettings.noRepeatBeforeY) {							if (pos.y<repeatSettings.noRepeatBeforeY) {								pos.y += repeatSettings.repeatEveryY/scrollFactor.y;							}						}						updateRenderPositon();					}				}		}	}}