package  no.agens.fungrid {	import flash.geom.Point;	import flash.display.BitmapData;	import flash.geom.Rectangle;		public class BlitGameObject extends HardCoreGameObject {		/** The position of the BlitGameObject relative to the viewport */		public var renderPos:Point;		/** Bitmap data for rendering */		public var spriteSheet:BitmapData;		/** Define rectangular areas on spriteSheet for rendering */		public var spriteRects:Vector.<Rectangle>;		/** What of the spriteRects to use for rendering */		public var spriteRectsIndex:uint = 0;		/** True if some kind of animation of the spriteRects is going to happen */		public var animateSprites:Boolean;				public function BlitGameObject(id:String,spriteSheet:BitmapData, spriteRects:Vector.<Rectangle>, initPos:Point, scrollFactor:Point=null, animateSprites:Boolean = false) {			super(id,null,initPos,scrollFactor);			this.spriteSheet = spriteSheet;			this.spriteRects = spriteRects;			this.animateSprites = animateSprites;			renderPos = new Point();		}		/** Updates the position on the grid and the sprite position in the viewport, and then render... */		override public function update():Boolean {			if (destroyMe) {				return false;			}			customEarlyUpdate();			updateRenderPositon();			if (animateSprites) {				animate();			}			render();			return true;		}		/** Do animation here */		protected function animate():void {					}		/** Renders sprite if the spriteRect is inside the viewport */		override protected function render():void {			if (inViewport() && !destroyMe) {				trace(renderPos.toString());				fg.blittingCanvas.copyPixels(spriteSheet, spriteRects[spriteRectsIndex], renderPos);			}		}		/** Updates the position of the sprite relative to the viewport */		override public function updateRenderPositon():void {				if (scrollFactor.x != 0) {					renderPos.x = scrollFactor.x*(pos.x-fg.viewport.x)+spriteRects[spriteRectsIndex].width*0.5;				} else {					renderPos.x = pos.x+spriteRects[spriteRectsIndex].width*0.5;				}				if (viewportPositionIntervalX) {					renderPos.x = viewportPositionIntervalX.forceIntoInterval(renderPos.x+spriteRects[spriteRectsIndex].width*0.5);				}				if (scrollFactor.y != 0) {					renderPos.y=scrollFactor.y*(pos.y-fg.viewport.y)+spriteRects[spriteRectsIndex].height*0.5;				} else {					renderPos.y = pos.y+spriteRects[spriteRectsIndex].height*0.5;				}				if (viewportPositionIntervalY) {					renderPos.y = viewportPositionIntervalY.forceIntoInterval(renderPos.y+spriteRects[spriteRectsIndex].height*0.5);				}		}		/** If spriteRects[spriteRectsIndex] is inside the viewport */		override public function inViewport():Boolean {			return spriteRects[spriteRectsIndex].x-spriteRects[spriteRectsIndex].width*0.5+renderPos.x <= fg.viewport.width/fg.parentSprite.scaleX && spriteRects[spriteRectsIndex].right+spriteRects[spriteRectsIndex].width*0.5+renderPos.x >= 0 && spriteRects[spriteRectsIndex].top-spriteRects[spriteRectsIndex].height*0.5+renderPos.y <= fg.viewport.height/fg.parentSprite.scaleY && spriteRects[spriteRectsIndex].bottom+spriteRects[spriteRectsIndex].height*0.5+renderPos.y >= 0;		}		/** Make it possible for FunGrid to remove this GameObject */		override public function pleaseDestroy():void {			destroyMe = true;		}		/** Used by the FunGrid when destroying the GO. */		override public function destroy():void {			customDestroy();		}	}	}